{
  "questions": [
    {
      "question": "Що виведе на екран програма:\n\ndef days_of_the_week(day):\n    match day.lower():\n        case \"Monday\" | \"Tuesday\" | \"Wednesday\" | \"Thursday\" | \"Friday\":\n            return \"Weekday\"\n        case \"monday\" | \"tuesday\" | \"wednesday\" | \"thursday\" | \"friday\":\n            return \"weekday\"\n        case \"saturday\" | \"sunday\":\n            return \"Day off\"\n        case _:\n            return \"Input Error!\"print(days_of_the_week(\"Monday\"))",
      "options": [
        "weekday",
        "Помилка при виведенні",
        "Input Error!",
        "Weekday"
      ],
      "answer": "weekday",
      "explanation": "Функція перетворює вхідний рядок 'Monday' на нижній регістр 'monday' за допомогою .lower(). Далі match-оператор знаходить збіг із другим 'case' ('monday'|'tuesday'|...) і повертає рядок 'weekday', який і виводиться на екран."
    },
    {
      "question": "Мова Python відноситься до:",
      "options": [
        "компільованих мов",
        "трансльованих мов",
        "спеціалізованих мов",
        "інтерпретованих мов"
      ],
      "answer": "інтерпретованих мов",
      "explanation": "Python — це інтерпретована мова. Його код виконується інтерпретатором рядок за рядком, без попередньої компіляції в машинний код. Це робить процес розробки гнучкішим і швидшим."
    },
    {
      "question": "Є наступний код. Який результат виконання цього коду?\n\na = 10\nb = 5\nif a % 4 - a // 4 > 0:\n    print(1)\nelse:\n    print(a % b)",
      "options": ["Буде помилка.", "5", "0", "1"],
      "answer": "0",
      "explanation": "Умова 'if' обчислюється як (10 % 4) - (10 // 4), що дорівнює 2 - 2, тобто 0. Оскільки 0 не більше 0, умова хибна. Виконується блок 'else', де обчислюється 10 % 5, що дорівнює 0. На екран виводиться 0."
    },
    {
      "question": "Чи можливе використання циклу for з використанням гілки else?",
      "options": [
        "не передбачено циклічними конструкціями мови Python",
        "так",
        "інколи",
        "ні"
      ],
      "answer": "так",
      "explanation": "Гілка 'else' в циклі 'for' виконується тоді, коли цикл завершується природним шляхом (перебравши всі елементи), а не примусово за допомогою 'break'."
    },
    {
      "question": "Що буде, якщо передати аргумент у функцію, яка не приймає жодного аргументу?",
      "options": [
        "Буде помилка TypeError.",
        "Помилки не буде, але під час виклику треба зробити так: my_function().add_arg(my_argument).",
        "Помилки не буде, функція просто виконається.",
        "Помилки не буде, але буде попередження."
      ],
      "answer": "Буде помилка TypeError.",
      "explanation": "Функція, яка визначена без параметрів, очікує 0 аргументів. Спроба передати будь-який аргумент призведе до помилки 'TypeError' з повідомленням про невідповідність кількості аргументів."
    },
    {
      "question": "За що відповідає РЕР8?",
      "options": [
        "За візуальне оформлення коду",
        "За правильне використання циклів та розгалужень",
        "За правильне написання імен змінних",
        "За 19 правил Тіма Пітерса, або як його ще називають “Дзен Python”"
      ],
      "answer": "За візуальне оформлення коду",
      "explanation": "PEP 8 - це набір стандартів та рекомендацій, що стосуються стилю кодування в Python. Це допомагає зробити код більш читабельним і уніфікованим для всіх розробників."
    },
    {
      "question": "Що таке рекурсія?",
      "options": [
        "Парадигма програмування нарівні з ООП, яка передбачає, що все має бути зроблено через функції",
        "Метод реалізації задачі з використанням подвійного тіла циклу, комбінуючи for та while",
        "Метод реалізації завдання, коли функція викликає саму себе, тим самим “зациклюється”, але має умову виходу та змінний стан усередині",
        "Метод реалізації завдання, коли функція викликає саму себе доти, доки не буде досягнуто ліміту рекурсії"
      ],
      "answer": "Метод реалізації завдання, коли функція викликає саму себе, тим самим “зациклюється”, але має умову виходу та змінний стан усередині",
      "explanation": "Рекурсія - це техніка програмування, де функція викликає саму себе. Щоб уникнути нескінченного виклику, вона повинна мати базовий випадок (умова виходу) і змінювати свій стан, щоб наблизитися до цієї умови."
    },
    {
      "question": "Що робить оператор continue?",
      "options": [
        "Пропускає виконання тіла циклу, робить ще одну ітерацію та виводить із нього.",
        "Пропускає виконання тіла циклу лише на конкретній ітерації.",
        "Продовжує виконання тіла циклу.",
        "Перериває виконання тіла циклу та виводить із нього."
      ],
      "answer": "Пропускає виконання тіла циклу лише на конкретній ітерації.",
      "explanation": "Оператор 'continue' негайно зупиняє поточну ітерацію циклу і переходить до наступної, пропускаючи решту коду в тілі циклу для поточної ітерації."
    },
    {
      "question": "Як перевернути кортеж задом наперед?",
      "options": [
        "my_tuple[::-1]",
        "my_tuple.reverse()",
        "my_tuple[:-1]",
        "my_tuple.inverse()"
      ],
      "answer": "my_tuple[::-1]",
      "explanation": "Синтаксис зрізу [::-1] створює нову перевернуту копію послідовності. Метод '.reverse()' не може бути використаний, оскільки кортежі є незмінними."
    },
    {
      "question": "Чи може кортеж зберігати елементи різних типів даних?",
      "options": [
        "Ні, не може. Кортеж зберігає елементи попередньо зазначеного типу.",
        "Може, але їх треба перерахувати при оголошенні кортежу.",
        "Може, і для цього не потрібно додаткових дій.",
        "Може, але з великими втратами інформації."
      ],
      "answer": "Може, і для цього не потрібно додаткових дій.",
      "explanation": "Python — динамічно типізована мова, тому кортежі, як і списки, можуть містити елементи будь-яких типів даних одночасно без будь-яких додаткових дій."
    },
    {
      "question": "Навіщо потрібні розгалуження?",
      "options": [
        "Керувати пам'яттю для змінних.",
        "Такого немає в Python.",
        "Щоб дивитися, які дані є у рядках.",
        "Один зі способів контролювати хід виконання програми."
      ],
      "answer": "Один зі способів контролювати хід виконання програми.",
      "explanation": "Розгалуження (умовні конструкції 'if', 'elif', 'else') дозволяють програмі приймати рішення та виконувати різні блоки коду залежно від певних умов."
    },
    {
      "question": "На що звертає увагу інтерпретатор під час виконання операції '+' між двома значеннями?",
      "options": [
        "на оператор",
        "не знаю",
        "на значення",
        "спочатку на тип даних, а потім на значення"
      ],
      "answer": "спочатку на тип даних, а потім на значення",
      "explanation": "Оператор '+' поліморфний. Його поведінка залежить від типу даних операндів: він виконує арифметичне додавання для чисел і конкатенацію для рядків, списків та інших послідовностей."
    },
    {
      "question": "У чому недоліки рекурсії?",
      "options": [
        "Рекурсія повільна",
        "Рекурсія потребує використання великих обчислювальних потужностей",
        "Рекурсія має межу кількості викликів",
        "Рекурсія не має недоліків"
      ],
      "answer": "Рекурсія має межу кількості викликів",
      "explanation": "Рекурсія може призвести до помилки 'RecursionError' через обмеження на глибину рекурсії, яке існує в Python. Також вона є повільнішою за ітеративні рішення."
    },
    {
      "question": "Яке ключове слово в Python визначає, що ми оголошуємо функцію?",
      "options": ["function", "method", "def", "define"],
      "answer": "def",
      "explanation": "Ключове слово 'def' (скорочення від 'define') використовується для визначення функції. Синтаксис: 'def function_name(arguments):'."
    },
    {
      "question": "В умовних конструкціях можна зустріти наступні ключові слова:",
      "options": ["Усі зазначені", "and", "or", "not"],
      "answer": "Усі зазначені",
      "explanation": "'and', 'or', 'not' є логічними операторами, які дозволяють комбінувати та заперечувати умови в операторах 'if', 'elif' та 'while'."
    }
  ]
}
